%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


%\documentclass[preprint]{sigplanconf}
\documentclass[10pt]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{yfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
%\usepackage{mathpartir}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage{harmony}
\usepackage{marvosym}
\usepackage{multirow}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage[charter]{mathdesign}
\usepackage{natbib}
\usepackage{xspace}
\usepackage[mathcal]{euscript}
\usepackage[linesnumbered,ruled]{algorithm2e}

\renewcommand{\UrlBreaks}{\do\/\do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j\do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t\do\u\do\v\do\w\do\x\do\y\do\z}

% ____________________________________________________________
% Listings Package Configuration
% \usepackage[scaled]{beramono}

%\renewcommand*\ttdefault{txtt}
\usepackage[T1]{fontenc}

% This Deep Tex Voodoo is from
%   <http://www.latex-community.org/forum/viewtopic.php?f=5&t=2072>
% It's purpose is to make \lstinline normal size, without affecting
% \lstinputlisting.  It seems to work but I have no idea how or why,
% and I rather hope never to learn.
%\makeatletter
%\lst@AddToHook{TextStyle}{\let\lst@basicstyle\ttfamily\normalsize}
%\makeatother

\begin{document}

\conferenceinfo{SIGBOVIK '18}{Pittsburgh, PA, USA}
\copyrightyear{2018}
\copyrightdata{}

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{
Transactional Memory Concurrency Verification with Landslide
%That `Boring' Stuff Was Part of the Title, BTW. \\
%So was that. And that, and this too. \\
%You got it all, right? \\
%Or Just, ``More Boring Crap about ITG'', for Short. \\
%Oh, That Was Also Part of the Title.
}
% \subtitle{\em The Randomly-Scoped Lambda Calculus}
% \subtitle{Subtitle Text, if any}

\authorinfo{Ben Blum}{}{bblum@cs.cmu.edu}

\maketitle

\begin{abstract}
Hardware transactional memory is a recently-introduced concurrent programming paradigm
%backed by a set of new instructions on recent x86 CPUs,
which allows programmers to elide locks for performance in low-contention workloads.
However,
%using this feature
it
comes at a cost in implementation complexity:
%programmers must support their
fast-path code must be accompanied by backup paths to handle transaction failure.

We extend Landslide, a popular stateless model checker,
with a concurrency model for transactional memory
and evaluate it on several real-world transactional
benchmarks and data structure implementations.
\end{abstract}

\category{D.1.3}{Programming Techniques}{Concurrent Programming}
\category{D.2.4}{Software Engineering}{Software/Program Verification}

\keywords
landslide terminal, baggage claim, ground transportation, ticketing

\section{Introduction}
\label{sec:intro}

Transactional Synchronization Extensions (TSX) \cite{transactional-memory}
is an instruction set extension for x86 CPUs which adds hardware-based transactional memory.
The processor uses its existing cache coherence algorithm to
check for memory conflicts with other cores while temporarily staging a sequence of memory accesses.
If no other CPU accesses the same memory during the transaction,
the access sequence is committed to main memory atomically (with respect to visibility to other CPUs).
Otherwise, the accesses are discarded, the CPU's local state is reverted, and the transaction returns a failure code.

This feature can be used to replace conventional locking in performance-critical concurrent programs.
When a concurrent workload accesses largely thread-local data,
or disjoint sections of a shared data structure,
the contention rate between threads is low,
and transactions will often succeed.
Compared to programs which use conventional locks,
which use bus-locking atomic accesses even in the fastest code path,
TSX provides substantial performance improvements in such programs \cite{htm-experience, htm-performance, htm-mario}.
However, the possibility of transaction failure introduces additional implementation complexity:
programmers must also provide a backup plan
to safely resolve contention between threads,
usually involving conventional synchronization.
These backup paths must coordinate not only with other backup paths
but also with other fast paths which another thread may begin after the original transaction failed,
which even in the simplest transactions requires complex synchronization sequences
\cite{htm-mario}.
This introduces an additional dimension of nondeterminism into an already concurrent program,
and moreover, because transaction failure is expected to be rare,
% だからこそ
obscure interleavings between failure paths are difficult to expose during testing.

This motivates the use of stateless model checking (MC) \cite{verisoft}
to comprehensively verify these transactional programs,
fast paths failure paths and all.
MC aims to force the system to execute all possible thread interleavings under a given test case,
exhaustively checking for bugs or verifying their absence in the corresponding state space.
Many such model checkers exist, varying in
interleaving granularity, memory analysis, types of programs checked, and search ordering strategy
\cite{chess,dbug-ssv,spin,inspect,r4,portend,samc,mcr,randomized-scheduler}.
This work builds upon Landslide \cite{landslide,quicksand,landslide-phdthesis},
a simulator-based tester which checks both user- and kernel-level programs
and incorporates data-race analysis \cite{tsan,fasttrack} to find new preemption points
at memory access granularity.
Our contributions are as follows:

\begin{enumerate}
	\item We extend Landslide's concurrency model to include transaction failure as an additional source of nondeterminism;
	\item We provide a proof sketch that our implementation matches TSX's execution semantics,
	\item We evaluate the extended Landslide on several transactional programs, analyzing both its bug-finding and verification performance.
\end{enumerate}

The paper is organized as follows.
Section \ref{sec:intro} introduces the problem domain and motivates our research.
The other sections state the rest of the paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Background}

This section introduces the fundamental concepts and prior work
in both hardware transactional memory and stateless model checking,
which we propose to combine.

{\bf Hardware transactional memory.}
TSX was supported on consumer hardware for the first time by Intel's Haswell architecture \cite{htm-haswell},
which extends the x86 instruction set to provide
{\tt xbegin}, {\tt xend}, and {\tt xabort} for beginning, committing, and aborting
transactions, respectively.
Higher-level programming languages or compilers may offer libraries or intrinsics to access these instructions;
for C and C++ GCC provides intrinsics named {\tt \_xbegin()} and so on \cite{htm-gcc}.
Figure~\ref{fig:htm-example} shows an example program using TSX to synchronize access to a shared counter,
including a failure path which defaults to a conventional lock.
This example actually has a bug, which we will discuss in the next section;
the reader is encouraged to try to spot it before then.
Several related works formally prove the correctness of transactional memory {\em implementations}
\cite{specifying-verifying-tm,tm-correctness,tm-completeness,mc-tm-with-spin},
but verifying the client programs written to use transactions remains an open problem.

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{ll}
		%\texttt{void count() \{} \\
		%\texttt{~~~~for (int i = 0; i < 1000; i++) \{} \\
		1 & \texttt{if ((status = \_xbegin()) == SUCCESS) \{} \\
		2 & \texttt{~~~~x++;} \\
		3 & \texttt{~~~~\_xend();} \\
		4 & \texttt{\} else \{} \\
		5 & \texttt{~~~~mutex\_lock(\&m);} \\
		6 & \texttt{~~~~x++;} \\
		7 & \texttt{~~~~mutex\_unlock(\&m);} \\
		8 & \texttt{\}} \\
		%\texttt{~~~~\}} \\
		%\texttt{\}} \\
		\end{tabular}
	\end{center}
	\caption{Example transactional program.
		%The example {\tt count} routine from Figure~\ref{fig:mutex}, rewritten to use HTM.
		If the
		%transaction in the
		top branch aborts,
		%whether from a memory conflict or random system interrupt,
		%from the programmer's intention,
		execution will revert to the return of {\tt \_xbegin()}
		%{\tt status} will be assigned an error code
		and control will drop into the {\tt else} branch.
		The programmer can then use explicit synchronization
		%, such as a mutex,
		to resolve the conflict.}
	\label{fig:htm-example}
\end{figure}

Under software transactional memory (STM) \cite{stm-pldi06},
memory conflicts with other threads are the only reason for transaction failure
(apart from programmer-supplied explicit aborts);
hence, depending on program semantics, some transactions may be guaranteed to succeed.
However, hardware implementations (HTM) may also fail transactions
for several other reasons such as random system interrupts or exhausting the CPU's cache capacity.
Because timer interrupts can in principle occur at any moment,
and with arbitrary frequency (observable by the program, perhaps as a result of a heavily-loaded system),
in this paper we will simplify the failure model by saying that HTM transactions can fail for any reason.
We defer discussion of programs which distinguish the reason for aborts through the failure code to Section~\ref{sec:warpzone}.

{\bf Stateless model checking.}
Model checking (MC) \cite{verisoft} is a testing technique for systematically executing and verifying
the possible thread interleavings of a concurrent program.
The main research challenge is to cope with exponential explosion of the state space,
which is $O(n^k)$ for a program with $n$ operations and $k$ threads.
Some {\em stateful} MCs explicitly store and compare all visited states of the program being tested \cite{spin},
which both keeps track of test coverage
and allows identifying identical states to avoid testing redundant interleavings.
%
By contrast, {\em stateless} MC (henceforth abbreviated simply as MC)
stores only the current sequence of execution events to avoid a prohibitive memory footprint.
Reduction algorithms \cite{dpor,optimal-dpor,satcheck,mcr,mcr,tsopso}
can then analyze the memory accesses in that sequence to identify
interleavings observationally-equivalent under Mazurkiewicz trace theory \cite{mazurkiewicz} and hence safe to skip.
The resulting state spaces are still exponentially-sized,
but only in the number of conflicting operations rather than all operations.
Of these, Landslide uses Dynamic Partial Order Reduction (DPOR) \cite{dpor} to prune its state spaces.

MCs may instrument programs to introduce thread switches at varying granularity, which affects the number of operations $n$.
%The number of operations depends on how finely-grained the MC instruments the program to introduce thread switches.
Some target distributed systems, instrumenting only message-passing events \cite{modist};
some run multithreaded programs natively, instrumenting only the pthread API for performance \cite{dbug-ssv};
and some insert compiler instrumentation on statically-identified memory accesses \cite{chess,inspect}.
Landslide traces every memory access through the use of a simulated environment \cite{bochs},
which is important for identifying data races to use as new preemption points \cite{fasttrack,djit,quicksand},
as well as for identifying when a memory conflict may cause transaction aborts.
With regard to checking for bugs,
the ``model'' the name refers to being checked may be
an external formal specification,
the program's own internal consistency checks,
or a set of expected properties encoded in the tool itself.
Landslide uses the latter two cases, checking for assertion failures
as well as deadlocks, use-after-frees, and segfaults.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Design}
\label{sec:design}

This section presents our formalization of transactional memory in Landslide's framework of thread concurrency.
We make two major simplifications:
simulating transaction aborts as failure injections,
and treating transaction atomicity as a global mutex during data-race analysis;
and provide corresponding equivalence proofs.

{\bf Notation.} Let $I = TN_1@L_1, TN_2@L_2, ... TN_n@L_n$,
with $N_i$ a thread ID and $L_i$ a code line number,
denote the execution sequence of a program as it runs according to the specified thread interleaving.%
\footnote{This serialization of concurrent execution is told from the perspective of main memory
and hence assumes sequential consistency.
For discussion of relaxed memory models refer to Section~\ref{sec:warpzone}.}

\subsection{Example}

Consider again the program in Figure~\ref{fig:htm-example}.
Note that the C-style {\tt x++} operations, when compiled into assembly,
results in multiple memory accesses which can be interleaved with other threads.
\[
\begin{tabular}{ll}
	$2a$ & \texttt{temp <- x;} \\
	$2b$ & \texttt{temp <- temp + 1;} \\
	$2c$ & \texttt{x <- temp;} \\
\end{tabular}
\]

\newcommand\hilight[2]{\color{#1}#2\color{black}}
\definecolor{orange}{RGB}{192,96,0}
\definecolor{olivegreen}{RGB}{0,127,0}
\definecolor{brickred}{RGB}{192,0,0}
\definecolor{commentblue}{RGB}{0,0,192}
\definecolor{black}{RGB}{0,0,0}
%\definecolor{lavender}{RGB}{238,85,238}
%\definecolor{seafoam}{RGB}{85,238,102}
%\definecolor{salmon}{RGB}{238,102,85} % ee6655

\definecolor{lavender}{RGB}{178,65,178} % * 3/4
\definecolor{seafoam}{RGB}{65,178,76} % * 3/4
\definecolor{salmon}{RGB}{208,89,74} % * 7/8

% T1 T2 T3 but latex doesn't allow #s in cmd names
\newcommand\ti{\ensuremath{\hilight{lavender}{\mathbf{T1}}}\xspace}
\newcommand\tj{\ensuremath{\hilight{seafoam}{\mathbf{T2}}}\xspace}
\newcommand\tk{\ensuremath{\hilight{salmon}{\mathbf{T3}}}\xspace}

\newcommand\tiat[1]{\ensuremath{\hilight{lavender}{\mathbf{T1}@#1}}\xspace}
\newcommand\tjat[1]{\ensuremath{\hilight{seafoam}{\mathbf{T2}@#1}}\xspace}
\newcommand\tkat[1]{\ensuremath{\hilight{salmon}{\mathbf{T3}@#1}}\xspace}

If these instructions from the {\tt x++} in the transaction are preempted,
with another thread's access to {\tt x} interleaved in between,
the transaction will abort.
So, the interleaving
\[
	\tiat{1}, \tiat{2a}, \tiat{2b}, \tjat{1}, \tjat{2}, \tjat{3}, \tiat{2c}, \tiat{3}
\]
or, henceforth abbreviated for clarity:
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{2c-3}
\]
is not possible; rather, \ti will fall into the backup path:
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{4-7}
\]
However, the {\tt x++} operation from the failure path (correspondingly $6a$, $6b$, $6c$)
{\em can} be thusly separated with conflicting accesses interleaved in between,
since the mutex only protects the failure path against other failure paths,
but not against the transaction itself.
So (assuming {\tt x} is intended to be a precise counter rather than a sloppy one),
%losing one of the increments to which constitutes a bug),
we observe a bug in the following interleaving.%
\footnote{Note also that this bug requires either at least 3 threads or at least 2 iterations between 2 threads to expose;
this highlights MC's dependence on its test cases to produce meaningful state spaces in the first place.}
\[
	\tiat{1-2b}, \tjat{1-3}, \tiat{4-6b}, \tkat{1-3}, \tiat{6c-7}
\]
Prior work \cite{htm-mario} proposed the idiom shown in Figure~\ref{fig:htm-fixed}
to exclude this family of interleavings,
showing that correctly synchronizing even the simplest transactions may be surprisingly difficult or complex.
%further motivating our research.

\begin{figure}[t]
	\begin{center}
		\begin{tabular}{ll}
		%\texttt{void count() \{} \\
		%\texttt{~~~~for (int i = 0; i < 1000; i++) \{} \\
		  & \texttt{prevent\_transactions = false;} \\
		\\
		0 & \texttt{while (prevent\_transactions) continue;} \\
		1 & \texttt{if ((status = \_xbegin()) == SUCCESS) \{} \\
		2 & \texttt{~~~~if (prevent\_transactions)} \\
		3 & \texttt{~~~~~~~~\_xabort();} \\
		4 & \texttt{~~~~x++;} \\
		5 & \texttt{~~~~\_xend();} \\
		6 & \texttt{\} else \{} \\
		7 & \texttt{~~~~mutex\_lock(\&m);} \\
		8 & \texttt{~~~~prevent\_transactions = true;} \\
		9 & \texttt{~~~~x++;} \\
		A & \texttt{~~~~prevent\_transactions = false;} \\
		B & \texttt{~~~~mutex\_unlock(\&m);} \\
		C & \texttt{\}} \\
		%\texttt{~~~~\}} \\
		%\texttt{\}} \\
		\end{tabular}
	\end{center}
	\caption{Variant of the program in Figure~\ref{fig:htm-example},
		with additional synchronization to protect the failure path from the transactional path.
		The optional line 0 serves to prevent a cascade of failure paths
		for the sake of performance
		by allowing threads to wait until transacting is safe again.}
	\label{fig:htm-fixed}
\end{figure}

\subsection{Modeling Transaction Failure}

Left unstated in interleavings such as $\tiat{1-2c}, \tjat{1-3}, \tiat{4-7}$%
\footnote{For the sake of example I reorder \ti's write to {\tt x} before \tj's part here.}
are HTM's execution semantics, namely:
\begin{enumerate}
	\item any modifications to shared state (such as $2c$) by \ti are not visible to \tj during its execution,
		despite \tj being executed afterwards, and
	\item all local and global state changes by \ti between lines $1$ and $2c$ are discarded when jumping to line $4$.
\end{enumerate}
% there shouldbe a better word than 'requires' here.. benefits from.. "the point of it is"..
While use of TSX in production requires the performance advantage
of temporarily staging such accesses in local CPU cache,
model checking such programs need be concerned only with the program's {\em observable} behaviours.
We claim that MCing the interleaving $\tiat{1}, \tjat{1-3}, \tiat{4-7}$
is an equivalent verification as MCing the one above;
in fact, this interleaving suffices to check
all observable behaviours
of all interleavings
of all subsets of $\tjat{1-3}$
with all subsets of $\tiat{2a-2c}$,
whether they share a memory conflict or not.
Stated formally:

\renewcommand\proofname{Proof Sketch}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

\newcommand\tii{\ensuremath{\hilight{lavender}{\mathbf{Ti}}}\xspace}
\newcommand\tjj{\ensuremath{\hilight{seafoam}{\mathbf{Tj}}}\xspace}
\newcommand\tkk{\ensuremath{\hilight{salmon}{\mathbf{Tk}}}\xspace}

\newcommand\tiiat[1]{\ensuremath{\hilight{lavender}{\mathbf{Ti}@#1}}\xspace}
\newcommand\tjjat[1]{\ensuremath{\hilight{seafoam} {\mathbf{Tj}@#1}}\xspace}
\newcommand\tkkat[1]{\ensuremath{\hilight{salmon}  {\mathbf{Tk}@#1}}\xspace}

\begin{lemma}[Equivalence of Aborts]
	\label{lem:equiv}
	Let:%
	\footnote{Arbitrary code may not be structured to distinguish these as nicely as in our examples;
	e.g., more code may exist in the success branch after {\tt \_xend()};
	such would be considered part of $\omega$ here.}
	\begin{itemize}
		\item $\tiiat{\alpha}$ be an HTM begin operation,
		\item $\tiiat{\beta_1}\dots\tiiat{\beta_n}$ be the transaction body (with $\beta_n$ the HTM end call),
		\item $\tiiat{\phi_1}\dots\tiiat{\phi_m}$ be the failure path, and
		\item $\tiiat{\omega_1}\dots\tiiat{\omega_l}$ be the subsequent code executed unconditionally.
	\end{itemize}
	Then, for any interleaving prefix%
	\footnote{Without loss of generality: for any number of other threads \tjj/\tkk,
	and for any number of thread switches away from \tii during the transaction.}
	\[
	\begin{tabular}{c}
		$\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b},$\\
		$\tjjat{\gamma_1}\dots\tjjat{\gamma_j},$ \\
		$\tkkat{\kappa_1}\dots\tkkat{\kappa_k},$ \\
		$\tiiat{\beta_{b+1}}$ % $\dots\tiiat{\beta_{n-1}}$ -- excluded bc might abort
	\end{tabular}
	\]
	with $b<n$, $j \ne i$, $k \ne i$, etc., either:
	\begin{enumerate}
		\item $\tiiat{\alpha},\tjjat{\gamma_1}\dots\tjjat{\gamma_j},\tkkat{\kappa_1}\dots\tkkat{\kappa_k},\tiiat{\phi_1}\dots$
			(conflicting case), or
		\item $\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b}\dots\tiiat{\beta_n},\tjjat{\gamma_1}\dots\tjjat{\gamma_j},$ \\
			$\tkkat{\kappa_1}\dots\tkkat{\kappa_k}$
			(independent case)
	\end{enumerate}
	is observationally equivalent.
\end{lemma}

\begin{proof}
	We case on whether the operations by \tjj and/or \tkk have any memory conflicts (read/write or write/write)
	with $\tiiat{\beta_1}\dots\tiiat{\beta_n}$.
	If so, then the hardware will abort \tii's transaction, discarding the effects of $\tiiat{\beta_1}\dots\tiiat{\beta_n}$
	and jumping to $\tiiat{\phi_1}$,
	satisfying case 1.
	Otherwise, by DPOR's definition of transition dependence \cite{dpor,landslide-phdthesis},
	$\tiiat{\beta_{b+1}}\dots\tiiat{\beta_n}$ is independent with the transitions of \tjj and \tkk,
	may be successfully executed until transaction commit,
	and reordering them produces an equivalent interleaving,
	satisfying case 2.
\end{proof}

The second part of our claim follows naturally.

\begin{theorem}[Atomicity of Transactions]
	\label{thm:atom}
	For any state space $U$ of a transactionally-concurrent program,
	an equivalent state space exists in which all transactions are either executed atomically or aborted immediately.
\end{theorem}

\begin{proof}
	For every $I \in U$ with $\tiiat{\alpha},\tiiat{\beta_1}\dots\tiiat{\beta_b},$ $\tjjat{\dots},\tkkat{\dots},\tiiat{\beta_{b+1}} \in I$,
	apply Lemma~\ref{lem:equiv} to obtain an equivalent interleaving $I'$ satisfying the theorem condition.
	The resulting $U'$ can then be MCed without simulating HTM rollbacks.
\end{proof}

\subsection{Memory Access Analysis}

Next, we address the memory accesses within transactions with regard to data-race analysis.
From Theorem~\ref{thm:atom} we have that the body of all transactions may be executed atomically within the MC environment.
While they may interleave within other non-transactional sequences,
no other operations (whether transactional or not) will interrupt them.
We claim this level of atomicity is equivalent to that provided by a global lock,
and hence abstracting it as such in Landslide's data-race analysis is sound.

\begin{theorem}[Transactions are a Global Lock]
	asdfasdfaf
\end{theorem}

\begin{proof}
	asdfasdf
\end{proof}

\subsection{Implementation}

Our implementation of HTM has been incorporated by the Landslide maintainers upstream.
The repository is available open-source at \url{https://github.com/bblum/landslide}.
Programs should be ported to the Pebbles userland \cite{thrlib,kspec},
their use of compiler HTM intrinsics should be replaced with the Landslide stubs provided in {\tt 410user/inc/htm.h},
and HTM nondeterminism can then be enabled with the {\tt -X} command-line flag.
Several example tests are also provided:
{\tt htm1} demonstrates the bug in Figure~\ref{fig:htm-example},
and {\tt htm2} demonstrates Figure~\ref{fig:htm-fixed}'s fix.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Evaluation}

To the best of our knowledge, this is the first work to test transactional programs in a model-checking environment,
%To the best of the author's knowledge, Landslide is the first MC to check transactional concurrency,
so no other MC State-of-the-Art%
\footnote{My DJ name.}
exists to compare to in controlled experiments.
Nevertheless, we pose the following evaluation questions.

\begin{enumerate}
	\item How quickly does Landslide find bugs in incorrect transactional programs of varying sizes?
	\item How quickly does Landslide verify correct transactional programs of varying sizes?
	\item Does Landslide find any previously-unknown bugs in real-world transactional code?
\end{enumerate}

Our evaluation suite comprises several hand-written unit tests,
as well as \cite{htm-mario}'s microbenchmarks and transactional AVL tree and separate-chaining hashmap.
All tests were run on an 8-core 2.7GHz Core i7 with 32 GB RAM.

...We don't actually have any results here yet.
We intended to update our submission before camera-ready,
but if somehow this becomes the final conference version of the paper,
please look to \cite{landslide-phdthesis}, coming soon.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Limitations}
\label{sec:warpzone}

This section discusses opportunities for future work.

{\bf Transaction failure codes.}
When a transaction fails, {\tt \_xbegin()} returns a failure code
denoting the reason, or combination thereof, therefor \cite{htm-gcc}.
If a program then cases on that failure code to select between different backup paths,
model checking it by simply injecting a single type of failure may be unsound.
For example, a program executing a transaction which is guaranteed to never conflict with any other threads,
and hence never abort without {\tt \_XABORT\_RETRY},
could legally {\tt assert(false);} in its failure path,
while our approach in Section~\ref{sec:design} would erroneously trigger that assertion and report a bug.
Likewise, the transactional data structures from \cite{htm-mario}
abstract away any spurious {\tt \_XABORT\_RETRY} aborts behind a retry loop;
a MC unwise to that idiom would call it an infinite loop bug.

Our HTM implementation in Landslide includes an experimental feature
to track the set of abort codes possible for each transaction.
It harnesses DPOR's existing memory analysis to identify when {\tt \_XABORT\_CONFLICT} is possible,
and instruments {\tt \_xabort()} calls to record any user-supplied codes.
This comes at a cost of even more state space explosion,
increasing the exponent at each {\tt \_xbegin()} preemption point
by (usually) 1 plus however many distinct {\tt \_xabort()} codes the program uses.
Future work could use static or dynamic flow analysis to
identify which transactions actually branch on their failure codes
to prune equivalent backup paths;
for now, this feature is disabled by default but accessible via the {\tt -A} command-line option
to Landslide (in addition to {\tt -X}).

{\bf Relaxed memory orderings.}
Section~\ref{sec:design}'s formalization of thread interleavings does not account for read/write reorderings
possible on relaxed memory consistency architectures \cite{memory-consistency-models}.
In fact,
even after \cite{htm-mario}'s proposed fix,
our running example program is still incorrect on Total Store Ordering (TSO) architectures such as x86.
Despite stores being totally-ordered, x86 may still reorder stores after subsequent loads.
Accordingly, an execution of $8,9a,9b,9c$ in Figure~\ref{fig:htm-fixed}
may be locally visible to another thread as $9a,8,9b,9c$,
and hence an apparent interleaving of
\[
	\tiat{1},\tjat{1-5},\tiat{7},\underline{\tiat{9a}},\tkat{1-5},\underline{\tiat{8}},\tiat{9b-B}
\]
is possible
(reordered accesses underlined for emphasis).
An {\tt mfence} barrier is needed between lines 8 and 9 to solve this problem on TSO \cite{tsx-need-barrier}.
On Partial Store Ordering (PSO) architectures, even more barriers may be necessary.

Because Landslide's concurrency model includes only instruction-level thread nondeterminism,
not per-CPU memory buffer reorderings,
our current HTM implementation in Landslide cannot find this bug.
In fact, it erroneously verifies the corresponding test {\tt htm2} in 7 CPU-minutes,
with 294 distinct interleavings in total,
none of which include the above-listed sequence.
Recent work extended DPOR to incorporate TSO and PSO memory nondeterminism \cite{tsopso};
if incorporated into Landslide, we could find or verify the absence of such bugs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

Stateless model checking research is a perpetual existence of staring up the sheer cliff face that is the exponential curve.
As new concurrency paradigms emerge,
we make our living by adapting our reduction algorithms and search strategies to them to climb ever higher on that curve,
eking out a few more loop iterations or slightly higher thread counts in our verification guarantees.
Whether that is beautiful in its imperfection or cause for despair is merely a matter of perspective.
Also, the author hopes their committee won't mind the publication venue when they cite this in their thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrv}
\bibliography{citations}

\end{document}
